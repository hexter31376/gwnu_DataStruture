#include <stdio.h>

/**
 * 쉘 정렬의 기본적인 아이디어는 다음과 같습니다.
 * 삽입 정렬은 어느 정도 정렬된 정렬에 대해서는 매우 효율적인 정렬 시간을 가집니다.
 * 그러나 삽입 정렬은 삽입 후에 위치에서 많이 벗어나 있는 원소도 한 단계에서 한칸씩 밖에 이동하지 못한다는 사실입니다.
 * 즉 키 값이 큰 원소들이 앞에 몰려 있다면 상대적으로 정렬 시간은 오래 걸리게 됩니다.
 * 삽입 정렬의 어느 정도 정렬된 리스트에 대한 빠른 속도를 자랑하는 삽입 정렬의 장점을
 * 유지하면서 키 값이 큰 배열 요소를 뒤로 한번에 보낼 수 있는 방법을 고안했는데 그것이 쉘 정렬입니다.
 * 쉘 정렬은 '갭'을 정하고 그 '갭'만큼 떨어진 요소들끼리만 삽입 정렬을 진행합니다.
 * 그리고 그 갭을 점점 줄여가면서 갭이 1이 되는 순간 일반 삽입 정렬을 진행하게 되는데
 * 이 과정을 통해 얻는 장점으로는
 * 1. 어느정도 키값이 큰 요소가 한번에 뒤로 이동하게 된다
 * 2. 따라서 그냥 쌩 삽입 정렬을 진행하는 것 보다 효율이 증대된다.
 * 갭의 어떤 값이 제일 적절한지는 아직 결정되지 않은 문제이다.
 * 그러나 커누스가 정의한 다음 재귀 정의를 주로 사용한다.
 * 이는 O(n^1.5)의 시간 복잡도를 보장한다.
 *  > h[1] = 1
 *  > h<-[h + 1] = h<-[3h + 1]
 * 위 재귀식은 다음과 같은 순열을 생성한다
 * 1, 4, 13, 40, 121
 * 리스트의 길이가 20일때
 * 13 < 20 < 40 이므로
 * 갭은 13, 4, 1 순으로 줄어들어 그 갭에 대한 삽입 정렬을 진행하게 된다.
 */

void shell_sort (int list[], int n) {
    int i, j, h = 1, next;
    // 갭 순열의 시작 계산
    while (h < n) { // n보단 작은 값을 찾을때까지
        h = 3 * h + 1; // h에 3을 곱하고 1을 더해서 h에 집어넣어라
    }
    while (h > 1) {
        h = h / 3; // 갭 순열의 다음 값
        for (i = h; i < n; i++) {
            next = list[i]; // i번째 요소를 다음 요소로 지정
            for (j = i - h; j >= 0 && next < list[j]; j = j - h) {
                list[j + h] = list[j];
            }
            list[j + h] = list[j];
        }
    }
}